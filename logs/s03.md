# Session 3 (1/27) - [Snow_Day_Readings]

## What I learned today
#### Chapter 1: Programming as a way of thinking
###### Summary:
This chapter essentially went over the basics and transitional language that I may have to understand before getting into the deeper parts of coding with python. Though a lot of these concepts are kind of similar to R and RStudio, so I don't think i'll have much trouble transfering my thought process. 

The main point I guess should be the differentiation of **Natural** and **Formal** language. Natural language is just everyday speach that's full of interpretation and abiguity, while formal language are ones that's created for specific situations. They're more concise and clear without redundancy (also this is my first time learning that arithmetic operators were a formal language!). Any further detail on what i've learned would be simply *redundant* as i've already written them down in the glossary below

I've included a personal glossary below just to track my understanding, please let me know if it's too much for a learning log and I'll transfer them elsewhere, but I find that it really helps me keep track of the reading and conceptual understanding. 

There's another section even further down for Chapter 2 btw.

###### Glossary
- *Arithmetic Operator*: Any symbol that represents arithmetic calculations. Basically your standard calculation symbols like +, -, * (Multiplication), / (Division), // (Integer division aka. floor division), ** (Exponents).
    - *Integers*: Whole numbers
    - *Floating-Point numbers*: Decimal numbers
        - **Note**: When preforming +, -, or * on an integer result will be integer. Using / makes it a Floating-Point number. Divide integers with // to result in an integer
- *Expression*: Collection of operators and numbers. Python follows order of operations 
- *Functions*: Similar to functions in excel and R. (e.g. round(###) takes any floating point number and rounds to nearest integer)
    - *Function Call*: The act of "calling" or using a function.
- *Strings*: Sequences of letters denoted by quotation marks. 'text' and "text" both work. 
    - **Note**: Be sure to use quotations (' or ") and **NOT** backticks (`)
- *Concatenation*: Use of arithmetic operators to manipulate text. 
    - +: Joins two different texts 
    - *: Makes multiple copies and joins them
- *len()*: A function that can be called and provides the legth of a string (Counts letters between quotes but not the quotes itself)
- *Types*: Similar to variables types in R but in this case "values" instead. 
    - *type()*: Function that tells you the value type
        - *Int*: integers
        - *float*: floating point numbers 
        - *str*: strings   
            - **Note**: The above can also be used as functions and typecast values
- *Natural Language*: Naturally evolved languages that you and I speak everyday. (English, etc.)
- *Formal Language*: Languages designed by people for specific application. (Arithmetic symbols, Programming, etc.)
    - *Ambiguity*: Natural languages are meant to be interpreted, Formal language usually only ever has one clear meaning regardless of context.
    - *Redundancy*: Natural is verbose to make up for misunderstandings due to ambiguity, Formal is less redundant and more concise.
    - *Literalness*: Natural has idioms and metaphors, Formal means exactly what they say
- *Bugs*: Programming errors
- *Debugging*: Process of fixing the errors 

#### Chapter 2: Variable and Statements
###### Summary:
From what I understand, this chapter is an extention of the first and delves deeper into the *formal* language of python. Most notably, variables and statements of which are probably the backbone of the python language (don't quote me on that). Variables are basically a container of some value, be it a number or words similar to how variables and vectors work in R. 

The title of this chapter signifies statements, but from what I understand statment and expressions should go hand and hand. Can I say every expression evaluated is a statement executed? Every line of code should have some expression, but when ran they either display a result or don't.


###### Glossary:
- *Variable*: Name that refers to some value (Similar to vectors in R. They are **NOT** the same though)
    - *Assignment Statement*: The act of creating a variable (e.g. x = 67)
        - **Note**: You can apply arithmetic operators and functions to variables just like regular values
- *State Diagram*: Better with a visual, but essentially the *Environment* tab in RStudio that tells you what values a vector contains, in this case you've written it on paper or some software to denote what value a variable holds.
- *Variable Names*: What you call or assign your variable to be denoted as. 
    - **Note**: Variable names can **NOT** start with a number. Good practice also tells you to use lowercase, but it's not illegal to use uppercase 
- *Keywords*: Built in python variables that can **NOT** be used as variable names. No need to memorize them since they have a special color denotion in may python systems.
- *import*: One of the more important keywords that lets you access more python features using modules
- *Module*: A collection of variables and functions 
- *Expression*: Can be a single value (Integers, Floats, Strings) or a collection of values and operators. It can also include variable names and function calls.
    - *Evaluation*: Computing the value of an expression (You're evaluating some expression and displaying it's value)
    - *print()*: Function to display more than one expression at a time
- *Statement*: Unit of code that has an effect but **NO** output. (e.g. x = 67 will **NOT** produce any output but will internally store 67 into the variable x, imports are also statements.)
    - *Execution*: Running a statement (You're executing some statement, but there's no need to *evaluate* or display the result)
- *Argument*: The expression withing a function (e.g. int('101'))
- *Comments*: Natural language notes to better understand formal language code once it becomes too dense. Just a good practice really. (Use #, comments will **NOT** be ran when executing code)
    - **Note**: Good comments do not redundantly tell what the code does, rather explain *why* the code was written
- *Debugging*: There are three kind's of error you'll run into; Syntax, Runtime, and Semantic.
    - *Syntax Error*: Refers to structure and of a program and rules about the structure. More often than not I'm pretty sure this refers to misspelling something
    - *Runtime Error*: aka. exception; This happens when there are no syntax errors, but something still goes wrong, something exceptional.
    - *Semantic Error*: There is no error message and the code runs, but it doesn't do what you wan't.


## Code/work I'm proud of (optional)
Always proud of glossaries! They always seem to have such substance to them once you finish

## Challenges I faced
Nothing notable

## AI usage (if any)
Remembering shortcuts like how "ctrl + p" opened the command palette. Also realising that "ctrl + B" doesn't bold text in VSCode, but rather opens and closes the explorer tab.

## Questions for next time
My definition of and *expression* was a direct rip from the textbook's definition, but I still have a little trouble understanding conceptially what is considered an expression. Is it literally the *expression* of some value, where value is some umbrella term that contains "single values, a collection of values and operators, etc."?